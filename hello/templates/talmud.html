{% extends "base.html" %}
{% load staticfiles %}

{% block content %}

<html lang="en">
<head>
<meta charset="utf-8">
    <title>Mi vami - Graph Database of the Talmud 1.0</title>
<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="https://github.com/jiahuang/d3-timeline/blob/master/src/d3-timeline.js"></script>
<style type="text/css">
#divA
{
  float:left;
  border:1px solid blue;
  padding: 10px;
  width:45%;
}
#divB
{
  float:right;
  border:1px solid red;
  width:50%;
}
.he
{
    font-size:130%;
    font-family:"Frank Ruehl Libre","Times New Roman",serif;
    text-align:right;direction:rtl;
}
.en
{
    font-family:"adobe-garamond-pro",Georgia,serif;
    text-align:left;direction:ltr;
}

.Tanna {
    font-family: 'courier';

}

.Tanna[generation="unknown"] {
    background-color: orange;
    color: white;
}

.Amora[generation="unknown"] {
    background-color: orange;
    color: white;
}

.Tanna[generation="1"] {
    background-color: pink;
}

.Amora[generation="1"] {
    background-color: pink;
}

.Tanna[generation="1/2"] {
    background: linear-gradient(to right, pink, yellow);
}

.Amora[generation="1/2"] {
    background: linear-gradient(to right, pink, yellow);
}

.Tanna[generation="2"] {
    background-color: yellow;
}

.Amora[generation="2"]{
    background-color: yellow;
}

.Tanna[generation="2/3"] {
    background: linear-gradient(to right, yellow, salmon);
}

.Amora[generation="2/3"] {
    background: linear-gradient(to right, yellow, salmon);
}

.Tanna[generation="3"] {
    background-color: salmon;
}
.Amora[generation="3"] {
    background-color: salmon;
}

.Tanna[generation="3/4"] {
   background: linear-gradient(to right, salmon, lime);
}

.Amora[generation="3/4"] {
    background: linear-gradient(to right, salmon, lime);
}

.Tanna[generation="4"] {
    background-color: lime;
}

.Amora[generation="4"]{
    background-color: lime;
}

.Tanna[generation="4/5"]{
   background: linear-gradient(to right, lime, cyan);
}
.Amora[generation="4/5"]{
   background: linear-gradient(to right, lime, cyan);
}

.Tanna[generation="5"]{
    background-color: cyan;
}
.Amora[generation="5"]{
    background-color: cyan;
}

.Tanna[generation="5/6"]{
    background: linear-gradient(to right, cyan, mediumorchid);
}
.Amora[generation="5/6"]{
    background: linear-gradient(to right, cyan, mediumorchid);
}
.Tanna[generation="6"] {
    background-color: mediumorchid;
}

.Amora[generation="6"] {
    background-color: mediumorchid;
}

.VERB {
    background-color: white;
}

.VERB_show {
    background-color: lightblue;
}

/* Tooltip text */
.Amora:hover:after, .Tanna:hover:after {
    width: 120px;
    background-color: black;
    font-weight: bold;
    color: #fff;
    text-align: center;
    padding: 5px 0;
    border-radius: 6px;
    white-space: pre-wrap;
    content: attr(fullname) ' ' attr(class) ' Generation: ' attr(generation);

    /* Position the tooltip text - see examples below! */
    position: absolute;
    z-index: 1;
}

    .axis path,
    .axis line {
      fill: none;
      stroke: black;
      shape-rendering: crispEdges;
    }
    .axis text {
      font-family: sans-serif;
      font-size: 10px;
    }
    .timeline-label {
      font-family: sans-serif;
      font-size: 12px;
    }
    #timeline2 .axis {
      transform: translate(0px,40px);
      -ms-transform: translate(0px,40px); /* IE 9 */
      -webkit-transform: translate(0px,40px); /* Safari and Chrome */
      -o-transform: translate(0px,40px); /* Opera */
      -moz-transform: translate(0px,40px); /* Firefox */
    }

    .coloredDiv {
      height:20px; width:20px; float:left;
    }

</style>
</head>
<body>

<div id="container">
    <span id="divA">
        <button onclick="showVerb()">Show verbs</button>
        <button onclick="draw_student_graph()">Teacher/Student Graph</button>
        <button onclick="draw_local_interaction_graph()">Local Interactions Graph</button>
        <button onclick="draw_global_interaction_graph()">Global Interactions Graph</button>
        <button onclick="timelineHover()">Timeline</button>
{{ leftside | safe }}
    </span>
    </div>
    <div id="divB"></div>

<script type="text/javascript">
function draw_graph(n, e, bLegend) {
    // we may have multiple edges from node a to node b.
    // maybe these should be handled when populating the
    // database. however, our approach here is to merge
    // edges where target -> source are identical.
    {#edgeDictionary = {}#}
    {#for (var edge in e) {#}
    {#    edgeDictionary#}
    {#}#}

    d3.select("svg").remove();
    var w = 1200;
    var h = 900;
    var linkDistance = 200;
    var colors = d3.scale.category10();
    var dataset = {
        nodes: n,
        edges: e
}
    ;
    var svg = d3.select("#divB").append("svg").attr({"width": w, "height": h});

    var legendText = [ {'text': 'Legend: (outline means appears on page)', 'color': 'white'},
                        {'text': 'Tanna and Amora, generation 1', 'color': 'pink'},
                       {'text': 'Tanna and Amora, generation 2', 'color': 'yellow'},
                       {'text': 'Tanna and Amora, generation 3', 'color': 'salmon'},
                       {'text': 'Tanna and Amora, generation 4', 'color': 'lime'},
                       {'text': 'Tanna and Amora, generation 5', 'color': 'cyan'},
                       {'text': 'Tanna and Amora, generation 6', 'color': 'mediumorchid'}]

    if (bLegend) {
        svg.selectAll(".legendText")
            .data(legendText)
            .enter()
            .append('rect')
            .attr('x', 0)
            .attr('y', function (d, i) {
                return -20 + (i + 1) * 30;
            })
            .attr('width', 300)
            .attr('height', 30)
            .attr('fill', function (d, i) {
                return d.color;
            });

        svg.selectAll(".legendText")
            .data(legendText)
            .enter()
            .append('text')
            .text(function (d, i) {
                return d.text;
            })
            .attr('x', 0)
            .attr('y', function (d, i) {
                return (i + 1) * 30;
            });
    }
    var force = d3.layout.force()
        .nodes(dataset.nodes)
        .links(dataset.edges)
        .size([w, h])
        .linkDistance([linkDistance])
        .charge([-500])
        .theta(0.1)
        .gravity(0.05)
        .start();
    var edges = svg.selectAll("line")
        .data(dataset.edges)
        .enter()
        .append("line")
        .attr("id", function (d, i) {
            return 'edge' + i
        })
        .attr('marker-end', 'url(#arrowhead)')
        .style("stroke", "green")
        .style("pointer-events", "none");
    var nodes = svg.selectAll("circle")
        .data(dataset.nodes)
        .enter()
        .append("circle")
        .attr({"r": 40})
        .attr("class", ".circle")
        .style("fill", function (d, i) {
//return colors(i);
        generationColors = {'A1': 'pink', 'A2': 'yellow', 'A3': 'salmon', 'A4': 'lime', 'A5': 'cyan', 'A6': 'mediumorchid',
                            'T1': 'pink', 'T2': 'yellow', 'T3': 'salmon', 'T4': 'lime', 'T5': 'cyan', 'T6': 'mediumorchid'
                            };

        if (d.hasOwnProperty('generation'))
            if (d.generation in generationColors)
                 return generationColors[d.generation];
            else
                return 'white';
        else
            return colors(i);
        })
        .style('stroke', 'black')
        .style('stroke-width', function (d, i) {
            if (d.appears == 'True')
                return 2;
            else
                return 0;
        })
        .call(force.drag)
    var nodelabels = svg.selectAll(".nodelabel")
        .data(dataset.nodes)
        .enter()
        .append("text")
        .attr({
            "text-anchor": "middle",
            "class": "nodelabel",
            "stroke": "black",
            'font-size': 10
        })
        .text(function (d) {
            return d.name;
        })

    var nodelabels2 = svg.selectAll(".nodelabel2")
        .data(dataset.nodes)
        .enter()
        .append("text")
        .attr({
            "text-anchor": "middle",
            "class": "nodelabel",
            "stroke": "black",
            "font-size": 8
        })
        .text(function (d) {
            return d.generation;
        })


    var nodelabels = svg.selectAll(".nodelabel")
    var edgepaths = svg.selectAll(".edgepath")
        .data(dataset.edges)
        .enter()
        .append('path')
        .attr({
            'd': function (d) {
                return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y
            },
            'class': 'edgepath',
            'fill-opacity': 0,
            'stroke-opacity': 0,
            'fill': 'blue',
            'stroke': 'red',
            'id': function (d, i) {
                return 'edgepath' + i
            }
        })
        .style("pointer-events", "none");
    var edgelabels = svg.selectAll(".edgelabel")
        .data(dataset.edges)
        .enter()
        .append('text')
        .style("pointer-events", "none")
        .attr({
            'class': 'edgelabel',
            'id': function (d, i) {
                return 'edgelabel' + i
            },
            'dx': 80,
            'dy': 0,
            'font-size': 10,
            'fill': '#aaa'
        });
    edgelabels.append('textPath')
        .attr('xlink:href', function (d, i) {
            return '#edgepath' + i
        })
        .style("pointer-events", "none")
        .text(function (d, i) {
            return d['label']
        });
    svg.append('defs').append('marker')
        .attr({
            'id': 'arrowhead',
            'viewBox': '-0 -5 10 10',
            'refX': 50,
            'refY': 0,
            //'markerUnits':'strokeWidth',
            'orient': 'auto',
            'markerWidth': 10,
            'markerHeight': 10,
            'xoverflow': 'visible'
        })
        .append('svg:path')
        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
        .attr('fill', 'green')
        .attr('stroke', 'green');
    force.on("tick", function () {
        edges.attr({
            "x1": function (d) {
                return d.source.x;
            },
            "y1": function (d) {
                return d.source.y;
            },
            "x2": function (d) {
                return d.target.x;
            },
            "y2": function (d) {
                return d.target.y;
            }
        });
        nodes.attr({
            "cx": function (d) {
                return d.x;
            },
            "cy": function (d) {
                return d.y;
            }
        });
        nodelabels.attr("x", function (d) {
            return d.x;
        })
            .attr("y", function (d) {
                return d.y;
            });

        nodelabels2.attr("x", function (d) {
            return d.x;
        })
            .attr("y", function (d) {
                return d.y + 20;
            })

        edgepaths.attr('d', function (d) {
            var path = 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y;
            //console.log(d)
            return path
        });
        edgelabels.attr('transform', function (d, i) {
            if (d.target.x < d.source.x) {
                bbox = this.getBBox();
                rx = bbox.x + bbox.width / 2;
                ry = bbox.y + bbox.height / 2;
                return 'rotate(180 ' + rx + ' ' + ry + ')';
            }
            else {
                return 'rotate(0)';
            }
        });
    });
}

function draw_student_graph() {
    var nodes = {{ student_nodes | safe }};
    var edges = {{ student_edges | safe }};
    draw_graph(nodes, edges, true);
}

function draw_local_interaction_graph() {
    var nodes = {{ local_interaction_nodes | safe }};
    var edges = {{ local_interaction_edges | safe }};
    draw_graph(nodes, edges, true);
}

function draw_global_interaction_graph() {
    var nodes = {{ global_interaction_nodes | safe }};
    var edges = {{ global_interaction_edges | safe }};
    draw_graph(nodes, edges, true);
}

function showVerb() {
  var selects = document.getElementsByClassName("VERB");
  for(var i =0, il = selects.length;i<il;i++){
     selects[i].className = "VERB_show";
  }
}



var width = 500;

function timelineHover() {
var labelTestData = [{"label": "Rabbi Abba", "times": [{"starting_time": 290, "ending_time": 320}]}, {"label": "Rabbi Abba b. Hiyya b. Abba", "times": [{"starting_time": 290, "ending_time": 320}]}]
var chart = d3.timeline()
  .width(width*4)
  .stack()
  .margin({left:70, right:30, top:0, bottom:0})
  .hover(function (d, i, datum) {
  // d is the current rendering object
  // i is the index during d3 rendering
  // datum is the id object
    var div = $('#hoverRes');
    var colors = chart.colors();
    div.find('.coloredDiv').css('background-color', colors(i))
    div.find('#name').text(datum.label);
  })
  .click(function (d, i, datum) {
    alert(datum.label);
  })
  .scroll(function (x, scale) {
    $("#scrolled_date").text(scale.invert(x) + " to " + scale.invert(x+width));
  })
  .tickFormat( //
    {format: d3.format("i"),
    tickTime: d3.time.hours,
    tickInterval: 1,
    tickSize: 30});
var svg = d3.select("#timeline3").append("svg").attr("width", width)
  .datum(labelTestData).call(chart);
}



draw_student_graph();




</script>
</div>
</body>

{% endblock %}